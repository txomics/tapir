[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "TAPIR: Transcript analysis pipelines in R",
    "section": "",
    "text": "Book contents\nThis is where the good stuff goes.\nMaybe a description of the major sections…",
    "crumbs": [
      "Book contents"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "eda.html",
    "href": "eda.html",
    "title": "2  Exploratory data analysis",
    "section": "",
    "text": "How can we explore transcript expression from long read data…\nLet’s load some data…\n\nlibrary(here)\n\nhere() starts at /Users/milove/bioc/tapir\n\nurl &lt;- \"https://github.com/gandallab/Dev_Brain_IsoSeq/raw/main/data/cp_vz_0.75_min_7_recovery_talon_abundance_filtered.tsv.gz\"\nfilename &lt;- basename(url)\npath &lt;- here(\"data\",filename)\nif (!file.exists(path)) {\n  download.file(url, path)\n}\n\n\nlibrary(readr)\n\n\nAttaching package: 'readr'\n\n\nThe following objects are masked from 'package:testthat':\n\n    edition_get, local_edition\n\nraw_abundance_table &lt;- read_delim(path)\n\nRows: 214516 Columns: 35\n\n\n── Column specification ────────────────────────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr  (7): annot_gene_id, annot_transcript_id, annot_gene_name, annot_transcript_name, gene_novel...\ndbl (28): gene_ID, transcript_ID, n_exons, length, 209_1_VZ, 209_2_VZ, 209_3_VZ, 209_4_VZ, 334_1...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ndim(raw_abundance_table)\n\n[1] 214516     35\n\ncolnames(raw_abundance_table)\n\n [1] \"gene_ID\"               \"transcript_ID\"         \"annot_gene_id\"         \"annot_transcript_id\"  \n [5] \"annot_gene_name\"       \"annot_transcript_name\" \"n_exons\"               \"length\"               \n [9] \"gene_novelty\"          \"transcript_novelty\"    \"ISM_subtype\"           \"209_1_VZ\"             \n[13] \"209_2_VZ\"              \"209_3_VZ\"              \"209_4_VZ\"              \"334_1_VZ\"             \n[17] \"334_2_VZ\"              \"334_3_VZ\"              \"334_4_VZ\"              \"336_1_VZ\"             \n[21] \"336_2_VZ\"              \"336_3_VZ\"              \"336_4_VZ\"              \"334_1_CP\"             \n[25] \"334_2_CP\"              \"334_3_CP\"              \"334_4_CP\"              \"209_1_CP\"             \n[29] \"209_2_CP\"              \"209_3_CP\"              \"209_4_CP\"              \"336_1_CP\"             \n[33] \"336_2_CP\"              \"336_3_CP\"              \"336_4_CP\"             \n\nraw_abundance_table[1:5,1:15]\n\n# A tibble: 5 × 15\n  gene_ID transcript_ID annot_gene_id      annot_transcript_id annot_gene_name annot_transcript_name\n    &lt;dbl&gt;         &lt;dbl&gt; &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;           &lt;chr&gt;                \n1      12            21 ENSG00000268903.1… ENST00000494149.2_2 AL627309.6      AL627309.6-201       \n2      18            34 ENSG00000228463.4  ENST00000424587.2   AP006222.2      AP006222.2-001       \n3      22            39 ENSG00000224813.2  ENST00000445840.1   RP4-669L17.4    RP4-669L17.4-001     \n4      32            65 ENSG00000225630.1… ENST00000457540.1_1 MTND2P28        MTND2P28-201         \n5      33            66 ENSG00000237973.1… ENST00000414273.1_1 MTCO1P12        MTCO1P12-201         \n# ℹ 9 more variables: n_exons &lt;dbl&gt;, length &lt;dbl&gt;, gene_novelty &lt;chr&gt;, transcript_novelty &lt;chr&gt;,\n#   ISM_subtype &lt;chr&gt;, `209_1_VZ` &lt;dbl&gt;, `209_2_VZ` &lt;dbl&gt;, `209_3_VZ` &lt;dbl&gt;, `209_4_VZ` &lt;dbl&gt;\n\n\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following object is masked from 'package:testthat':\n\n    matches\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(tidyr)\n\n\nAttaching package: 'tidyr'\n\n\nThe following object is masked from 'package:testthat':\n\n    matches\n\nraw_abundance_table |&gt;\n  select(contains(c(\"VZ\",\"CP\"))) |&gt;\n  summarize(across(everything(), sum))\n\n# A tibble: 1 × 24\n  `209_1_VZ` `209_2_VZ` `209_3_VZ` `209_4_VZ` `334_1_VZ` `334_2_VZ` `334_3_VZ` `334_4_VZ` `336_1_VZ`\n       &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n1     623608     542318     501999     529527    1273843    1594927    1160553    1546123    1328077\n# ℹ 15 more variables: `336_2_VZ` &lt;dbl&gt;, `336_3_VZ` &lt;dbl&gt;, `336_4_VZ` &lt;dbl&gt;, `334_1_CP` &lt;dbl&gt;,\n#   `334_2_CP` &lt;dbl&gt;, `334_3_CP` &lt;dbl&gt;, `334_4_CP` &lt;dbl&gt;, `209_1_CP` &lt;dbl&gt;, `209_2_CP` &lt;dbl&gt;,\n#   `209_3_CP` &lt;dbl&gt;, `209_4_CP` &lt;dbl&gt;, `336_1_CP` &lt;dbl&gt;, `336_2_CP` &lt;dbl&gt;, `336_3_CP` &lt;dbl&gt;,\n#   `336_4_CP` &lt;dbl&gt;\n\n\n\nlibrary(here)\nfilename &lt;- \"cp_vz_0.75_min_7_recovery_talon_abundance_filtered.tsv.gz\"\npath &lt;- here(\"data\",filename)\nlibrary(readr)\nraw_abundance_table &lt;- read_delim(path)\n\nRows: 214516 Columns: 35\n── Column specification ────────────────────────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr  (7): annot_gene_id, annot_transcript_id, annot_gene_name, annot_transcript_name, gene_novel...\ndbl (28): gene_ID, transcript_ID, n_exons, length, 209_1_VZ, 209_2_VZ, 209_3_VZ, 209_4_VZ, 334_1...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ndim(raw_abundance_table)\n\n[1] 214516     35\n\ncolnames(raw_abundance_table)\n\n [1] \"gene_ID\"               \"transcript_ID\"         \"annot_gene_id\"         \"annot_transcript_id\"  \n [5] \"annot_gene_name\"       \"annot_transcript_name\" \"n_exons\"               \"length\"               \n [9] \"gene_novelty\"          \"transcript_novelty\"    \"ISM_subtype\"           \"209_1_VZ\"             \n[13] \"209_2_VZ\"              \"209_3_VZ\"              \"209_4_VZ\"              \"334_1_VZ\"             \n[17] \"334_2_VZ\"              \"334_3_VZ\"              \"334_4_VZ\"              \"336_1_VZ\"             \n[21] \"336_2_VZ\"              \"336_3_VZ\"              \"336_4_VZ\"              \"334_1_CP\"             \n[25] \"334_2_CP\"              \"334_3_CP\"              \"334_4_CP\"              \"209_1_CP\"             \n[29] \"209_2_CP\"              \"209_3_CP\"              \"209_4_CP\"              \"336_1_CP\"             \n[33] \"336_2_CP\"              \"336_3_CP\"              \"336_4_CP\"             \n\n\n\nlibrary(dplyr)\ncounts &lt;- raw_abundance_table |&gt;\n  select(gene_id = annot_gene_id,\n         feature_id = annot_transcript_id,\n         contains(c(\"VZ\",\"CP\")))\ncounts &lt;- counts |&gt;\n  rename_with(.cols = contains(c(\"VZ\",\"CP\")),\n              \\(x) paste0(\"s\", x))\nlibrary(tidyr)\nsamples &lt;- tibble(sample_id = colnames(counts)[-c(1:2)]) |&gt;\n  separate(sample_id, into=c(\"unit\",\"rep\",\"condition\"), sep=\"_\", remove=FALSE) |&gt;\n  mutate_at(c(\"rep\",\"condition\"), factor)"
  },
  {
    "objectID": "testing.html",
    "href": "testing.html",
    "title": "3  Statistical testing",
    "section": "",
    "text": "In this chapter we show differential gene expression (DGE) using DESeq2 and differential transcript usage (DTU) using satuRn.\nMost of the code here involves preparing the R objects for the methods. This is a bit complicated because we are importing data from files that were associated with a paper. I (Mike) would like to instead quantify this data with oarfish (with a current GENCODE + some novel transcripts) so we can demonstrate how easy it is to import with tximeta and use in R/Bioconductor pipelines. For now there are a lot of chunks that deal with data import manually.\nDownloading Glinos et al. dataset (GTEx, PTBP1 knockdown)\n\nlibrary(here)\n# https://drive.google.com/file/d/1ATHgwFlIMmI651C5TYtiBxm2atTvbBYn/view?usp=sharing\n# counts\nurl &lt;- \"https://drive.google.com/uc?export=download&id=1ATHgwFlIMmI651C5TYtiBxm2atTvbBYn\"\nfilename &lt;- \"quantification_flair_filter.counts.txt.gz\"\npath &lt;- here(\"data\", filename)\nif (!file.exists(path)) {\n  download.file(url, path)\n}\n# GTF\nurl &lt;- \"https://drive.google.com/uc?export=download&id=1S0TRXoXsfnXwJ0Dh5bLqVmyvFAAALFMU\"\nfilename &lt;- \"flair_filter_transcripts.gtf.gz\"\npath &lt;- here(\"data\", filename)\nif (!file.exists(path)) {\n  download.file(url, path)\n}\n# metadata\nurl &lt;- \"https://drive.google.com/uc?export=download&id=1LpYPXXhMtUV3vMG7SMLV69-JxZfc59o2\"\nfilename &lt;- \"glinos_metadata.csv\"\npath &lt;- here(\"data\", filename)\nif (!file.exists(path)) {\n  download.file(url, path)\n}\n\nAssembling the object manually from downloaded files.\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(stringr)\ncounts &lt;- read_delim(here(\"data\", \"quantification_flair_filter.counts.txt.gz\"))\nmeta &lt;- read_delim(here(\"data\", \"glinos_metadata.csv\"))\ncolnames(meta)[10] &lt;- \"total_reads\"\nmeta &lt;- meta |&gt;\n  mutate(condition = str_extract(sample_id, \"(ctrl|exp)\")) |&gt;\n  select(sample_id, sample_name, condition, contains(\"read\") | contains(\"3_prime\")) |&gt;\n  arrange(condition, sample_name)\n\nrnames &lt;- counts$transcript\ncounts &lt;- as.matrix(counts[,meta$sample_id]) # subset to the knockdown\nrownames(counts) &lt;- rnames\n\n\nlibrary(SummarizedExperiment)\nse &lt;- SummarizedExperiment(list(counts = counts),\n                           colData = meta)\n#saveRDS(se, file=here(\"data\", \"glinos_se.rds\"))\n\nFiltering for count of 10 across 6 or more samples.\n\nlibrary(here)\nlibrary(SummarizedExperiment)\nse &lt;- readRDS(here(\"data\", \"glinos_se.rds\"))\nkeep &lt;- rowSums(assay(se) &gt;= 10) &gt;= 6\ntable(keep)\n\nkeep\nFALSE  TRUE \n77437 16193 \n\nse &lt;- se[keep,]\n\nManual data processing:\n\nlibrary(DESeq2)\nlibrary(tximeta)\ncolsums &lt;- colSums(assay(se, \"counts\"))\ncpm &lt;- t(t(assay(se, \"counts\")) / colsums * 1e6)\nassay(se, \"abundance\") &lt;- cpm\n# dummy lengths... no correction for length\nassay(se, \"length\", withDimnames=FALSE) &lt;- matrix(1000, nrow=nrow(se), ncol=ncol(se))\n\n\nlibrary(dplyr)\nse$condition &lt;- case_when(\n    se$condition == \"ctrl\" ~ \"WT\",\n    se$condition == \"exp\" ~ \"KD\"\n)\n# note that protein knockdown will be used as reference \n# with this choice of factor levels\nse$condition &lt;- factor(se$condition, c(\"KD\",\"WT\"))\nse$condition\n\n [1] WT WT WT WT WT WT KD KD KD KD KD KD KD\nLevels: KD WT\n\n\nLoad a TxDb and produce some objects telling us about the transcripts.\n\nlibrary(stringr)\nlibrary(GenomicFeatures)\n#txdb &lt;- makeTxDbFromGFF(here(\"data\",\"flair_filter_transcripts.gtf.gz\"))\n#saveDb(txdb, file=here(\"data\",\"flair_filter_transcripts.sqlite\"))\ntxdb &lt;- loadDb(here(\"data\",\"flair_filter_transcripts.sqlite\"))\nexons &lt;- exonsBy(txdb, by=\"tx\")\ntxps &lt;- AnnotationDbi::select(txdb, keys(txdb, \"TXID\"), c(\"TXNAME\",\"GENEID\"), \"TXID\") |&gt;\n  tibble::as_tibble() |&gt;\n  dplyr::mutate(TXID = as.character(TXID))\n# better names for exons:\nlength(exons)\n\n[1] 93718\n\nall.equal(names(exons), txps$TXID)\n\n[1] TRUE\n\ntxps &lt;- txps |&gt;\n  dplyr::mutate(new_name = case_when(\n    str_detect(TXNAME,\"ENST\") ~ TXNAME,\n    TRUE ~ paste0(GENEID, \"-\", str_sub(TXNAME, 1, 8))\n  ))\nnames(exons) &lt;- txps$new_name\n#saveRDS(exons, file=here(\"data\",\"glinos_exons.rds\"))\n\nSummarize to gene level:\n\n# subsetting to only txp/gene with complete metadata\n# and renaming to have more legible names\nrownames(se) &lt;- str_replace(rownames(se),\"_ENSG\\\\d+\\\\.\\\\d+$\",\"\")\ntable(rownames(se) %in% txps$TXNAME) # these appear to be not genes\n\n\nFALSE  TRUE \n  933 15260 \n\ntxps &lt;- txps |&gt;\n  filter(TXNAME %in% rownames(se))\nse &lt;- se[txps$TXNAME,]\nrownames(se) &lt;- txps$new_name\nrowData(se)$isoform_id &lt;- txps$new_name\nrowData(se)$gene_id &lt;- txps$GENEID\ntx2gene &lt;- rowData(se)[,c(\"isoform_id\",\"gene_id\")]\ngse &lt;- summarizeToGene(se, tx2gene = tx2gene, skipRanges=TRUE)\n\nsummarizing abundance\n\n\nsummarizing counts\n\n\nsummarizing length\n\n#saveRDS(gse, file=here(\"data\",\"glinos_gene_counts.rds\"))\n\nDESeq2 DGE:\n\ndds &lt;- DESeqDataSet(gse, ~condition)\n\nconverting counts to integer mode\n\nkeep &lt;- rowSums(counts(dds) &gt;= 10) &gt;= 6\ntable(keep)\n\nkeep\nTRUE \n8780 \n\ndds &lt;- DESeq(dds, minRep=Inf)\n\nestimating size factors\n\n\nestimating dispersions\n\n\ngene-wise dispersion estimates\n\n\nmean-dispersion relationship\n\n\nfinal dispersion estimates\n\n\nfitting model and testing\n\nres &lt;- results(dds, cooksCutoff=FALSE)\nsummary(res)\n\n\nout of 8780 with nonzero total read count\nadjusted p-value &lt; 0.1\nLFC &gt; 0 (up)       : 1499, 17%\nLFC &lt; 0 (down)     : 1469, 17%\noutliers [1]       : 0, 0%\nlow counts [2]     : 0, 0%\n(mean count &lt; 7)\n[1] see 'cooksCutoff' argument of ?results\n[2] see 'independentFiltering' argument of ?results\n\n\nAdd gene symbols manually, make a simple plot of PTBP1 (the knocked-down gene).\n\nlibrary(org.Hs.eg.db)\n\n\n\ngene_anno &lt;- DataFrame(gene_id = str_replace(rownames(dds),\"\\\\.\\\\d+\",\"\"),\n                       baseMean = round(rowData(dds)$baseMean))\ngene_anno$symbol &lt;- org.Hs.eg.db |&gt; mapIds(gene_anno$gene_id, \"SYMBOL\", \"ENSEMBL\")\n\n'select()' returned 1:many mapping between keys and columns\n\ngene_anno$symbol[is.na(gene_anno$symbol)] &lt;- gene_anno$gene_id[is.na(gene_anno$symbol)]\nrowData(dds)$symbol &lt;- gene_anno$symbol\nidx &lt;- which(rowData(dds)$symbol == \"PTBP1\")\nset.seed(5) # for jittered plots\nplotCounts(dds, gene=idx)\n\n\n\n\n\n\n\n\nPCA plot:\n\nvsd &lt;- vst(dds, blind=FALSE)\nplotPCA(vsd)\n\nusing ntop=500 top features by variance\n\n\n\n\n\n\n\n\n\n\n#saveRDS(dds, file=here(\"data\", \"glinos_deseq2_gene.rds\"))\n#saveRDS(vsd, file=here(\"data\", \"glinos_vst_gene.rds\"))\n\nMake a Glimma report:\n\nlibrary(Glimma)\ng &lt;- glimmaMA(\n  dds,\n  groups=dds$condition,\n  anno=gene_anno[,-1],\n  main=\"Glinos et al. (2022) - PTBP1 knockdown\", # title above left summary plot\n  transform.counts=\"cpm\",\n  test=\"Wald\", name=\"condition_WT_vs_KD\",\n  independentFiltering=FALSE,\n  cooksCutoff=FALSE\n)\nhtmlwidgets::saveWidget(g, here(\"data\",\"glinos_ma-plot.html\"))\n\nNow, let’s look for DTU, first we do some processing of the SummarizedExperiment with plyxp.\n\nlibrary(plyxp)\nxp &lt;- se |&gt;\n  new_plyxp()\nxp &lt;- xp |&gt;\n  mutate(rows(gene = str_replace(gene_id, \"\\\\.\\\\d+\", \"\"),\n              symbol = mapIds(org.Hs.eg.db, gene, \"SYMBOL\", \"ENSEMBL\"),\n              symbol = dplyr::case_when(\n                is.na(symbol) ~ gene,\n                TRUE ~ symbol\n              )))\ntab &lt;- table(rowData(se)$gene_id)\none_isoform_gene &lt;- names(tab)[ tab == 1 ]\nxp &lt;- xp |&gt;\n  filter(rows(!gene_id %in% one_isoform_gene)) |&gt;\n  arrange(rows(gene_id))\n\n\nhead(table(table(rowData(xp)$gene_id))) # confirm no single isoform genes\n\n\n   2    3    4    5    6    7 \n1957  780  305  111   73   40 \n\n\nExtract the SE after we are done with plyxp filtering.\n\nse &lt;- se(xp)\n\nRun satuRn for DTU, first fit the model:\n\n# 5 seconds\nlibrary(satuRn)\nse &lt;- satuRn::fitDTU(se, formula=~0 + condition)\n\nBelow we compare WT (wildtype) to KD (knockdown), which is perhaps the reverse of how one might expect to define the comparison. Typically wildtype or control is used as the reference that the experimental condition is compared to. In this case, we use the knockdown as the reference, as it provides us with log2 fold changes with respect to the activity of the protein. For example, a transcript with a positive coefficient will be more likely to be expressed when the protein is abundant, and a transcript with a negative coefficient will be less likely to be expressed when the protein is abundant. Exons that appear in transcripts with negative coefficients may be down-regulated by the protein.\n\ndesign &lt;- model.matrix(~0 + condition, colData(se))\ncolnames(design)\n\n[1] \"conditionKD\" \"conditionWT\"\n\ncolnames(design) &lt;- levels(se$condition)\nL &lt;- limma::makeContrasts(\n  WT_vs_KD = WT - KD,\n  levels = design\n)\nL # contrast matrix\n\n      Contrasts\nLevels WT_vs_KD\n    KD       -1\n    WT        1\n\n\n\nse &lt;- satuRn::testDTU(\n  object = se,\n  contrasts = L,\n  diagplot1 = TRUE,\n  diagplot2 = TRUE\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#saveRDS(se, file=here(\"data\",\"glinos_saturn_dtu.rds\"))\n\nExtract test results:\n\nsig_res &lt;- rowData(se)[[\"fitDTUResult_WT_vs_KD\"]] |&gt;\n  tibble::as_tibble() |&gt;\n  dplyr::bind_cols(as.data.frame(rowData(se)[,1:4])) |&gt;\n  dplyr::filter(empirical_FDR &lt; .1) |&gt;\n  dplyr::select(gene_id, isoform_id, symbol, estimates, empirical_pval, empirical_FDR) |&gt;\n  dplyr::arrange(empirical_pval)\n#write.csv(sig_res, file=here(\"data\",\"glinos_saturn_dtu.csv\"), quote=FALSE, row.names=FALSE)\nsig_res\n\n# A tibble: 61 × 6\n   gene_id            isoform_id                  symbol estimates empirical_pval empirical_FDR\n   &lt;chr&gt;              &lt;chr&gt;                       &lt;chr&gt;      &lt;dbl&gt;          &lt;dbl&gt;         &lt;dbl&gt;\n 1 ENSG00000196923.13 ENST00000355841.6           PDLIM7      5.14    0.000000309       0.00304\n 2 ENSG00000198467.13 ENST00000378292.7           TPM2        2.93    0.00000324        0.0108 \n 3 ENSG00000138674.16 ENSG00000138674.16-d16d19d1 SEC31A      2.41    0.00000330        0.0108 \n 4 ENSG00000196923.13 ENSG00000196923.13-00a9e7dd PDLIM7     -4.92    0.00000854        0.0210 \n 5 ENSG00000198467.13 ENSG00000198467.13-7a434697 TPM2       -3.27    0.0000170         0.0252 \n 6 ENSG00000161203.13 ENSG00000161203.13-29f67f36 AP2M1      -1.51    0.0000172         0.0252 \n 7 ENSG00000134285.10 ENST00000552878.5-1         FKBP11     -1.98    0.0000179         0.0252 \n 8 ENSG00000134285.10 ENST00000550765.5           FKBP11      1.98    0.0000211         0.0259 \n 9 ENSG00000167460.14 ENST00000300933.8           TPM4        1.35    0.0000325         0.0304 \n10 ENSG00000161203.13 ENST00000382456.7           AP2M1       1.83    0.0000365         0.0304 \n# ℹ 51 more rows\n\n\nAs a demonstration of DTU, look at counts for the top gene:\n\ncpm &lt;- assay(se, \"abundance\")[rowData(se)$symbol == \"PDLIM7\",]\nrownames(cpm) &lt;- seq_len(nrow(cpm))\ncolnames(cpm) &lt;- se$condition\nround(cpm)\n\n   WT  WT  WT WT  WT WT  KD  KD  KD  KD  KD  KD  KD\n1   1   1   1  2   1  0  72  45  37  36  38  35  55\n2   1   2   2  2   1  1 295 190 150 146 175 183 236\n3 124 105 114 94 104 84  15   9  14  11   9  10  10\n4   4   2   4  2   4  1  19   9  15  13  11  12   7\n5   7   5   8 10   9  7   8   5   6   4   4   5   5\n6   0   0   1  0   2  0   6   7   6   6   5   8   5\n\n\n\nsessionInfo()\n\nR version 4.5.0 (2025-04-11)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Sequoia 15.5\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.1\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: America/New_York\ntzcode source: internal\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices datasets  utils     methods   base     \n\nother attached packages:\n [1] satuRn_1.16.0               plyxp_1.2.0                 org.Hs.eg.db_3.21.0        \n [4] GenomicFeatures_1.60.0      AnnotationDbi_1.70.0        stringr_1.5.1              \n [7] dplyr_1.1.4                 tximeta_1.26.1              DESeq2_1.48.1              \n[10] SummarizedExperiment_1.38.0 Biobase_2.68.0              GenomicRanges_1.60.0       \n[13] GenomeInfoDb_1.44.0         IRanges_2.42.0              S4Vectors_0.46.0           \n[16] BiocGenerics_0.54.0         generics_0.1.3              MatrixGenerics_1.20.0      \n[19] matrixStats_1.5.0           here_1.0.1                  rmarkdown_2.29             \n[22] devtools_2.4.5              usethis_3.1.0              \n\nloaded via a namespace (and not attached):\n  [1] RColorBrewer_1.1-3       jsonlite_2.0.0           tximport_1.36.0         \n  [4] magrittr_2.0.3           farver_2.1.2             fs_1.6.6                \n  [7] BiocIO_1.18.0            vctrs_0.6.5              locfdr_1.1-8            \n [10] memoise_2.0.1            Rsamtools_2.24.0         RCurl_1.98-1.17         \n [13] htmltools_0.5.8.1        S4Arrays_1.7.2           progress_1.2.3          \n [16] AnnotationHub_3.16.0     curl_6.2.2               SparseArray_1.8.0       \n [19] htmlwidgets_1.6.4        httr2_1.1.2              cachem_1.1.0            \n [22] GenomicAlignments_1.44.0 mime_0.13                lifecycle_1.0.4         \n [25] pkgconfig_2.0.3          Matrix_1.7-3             R6_2.6.1                \n [28] fastmap_1.2.0            GenomeInfoDbData_1.2.14  shiny_1.10.0            \n [31] digest_0.6.37            rprojroot_2.0.4          pkgload_1.4.0           \n [34] RSQLite_2.3.11           labeling_0.4.3           filelock_1.0.3          \n [37] httr_1.4.7               abind_1.4-8              compiler_4.5.0          \n [40] remotes_2.5.0            withr_3.0.2              bit64_4.6.0-1           \n [43] S7_0.2.0                 BiocParallel_1.42.0      DBI_1.2.3               \n [46] pkgbuild_1.4.7           biomaRt_2.64.0           rappdirs_0.3.3          \n [49] DelayedArray_0.34.1      sessioninfo_1.2.3        rjson_0.2.23            \n [52] tools_4.5.0              httpuv_1.6.16            glue_1.8.0              \n [55] restfulr_0.0.15          promises_1.3.2           grid_4.5.0              \n [58] gtable_0.3.6             tidyr_1.3.1              ensembldb_2.32.0        \n [61] hms_1.1.3                utf8_1.2.4               xml2_1.3.8              \n [64] XVector_0.48.0           BiocVersion_3.21.1       pillar_1.10.2           \n [67] limma_3.64.1             later_1.4.2              splines_4.5.0           \n [70] BiocFileCache_2.16.0     lattice_0.22-7           rtracklayer_1.68.0      \n [73] bit_4.6.0                tidyselect_1.2.1         locfit_1.5-9.12         \n [76] pbapply_1.7-2            Biostrings_2.76.0        miniUI_0.1.2            \n [79] knitr_1.50               ProtGenerics_1.40.0      xfun_0.52               \n [82] statmod_1.5.0            stringi_1.8.7            UCSC.utils_1.4.0        \n [85] boot_1.3-31              lazyeval_0.2.2           yaml_2.3.10             \n [88] evaluate_1.0.3           codetools_0.2-20         tibble_3.2.1            \n [91] BiocManager_1.30.25      cli_3.6.5                xtable_1.8-4            \n [94] Rcpp_1.0.14              dbplyr_2.5.0             png_0.1-8               \n [97] XML_3.99-0.18            parallel_4.5.0           ellipsis_0.3.2          \n[100] ggplot2_3.5.2            blob_1.2.4               prettyunits_1.2.0       \n[103] profvis_0.4.0            AnnotationFilter_1.32.0  urlchecker_1.0.1        \n[106] bitops_1.0-9             txdbmaker_1.4.1          scales_1.4.0            \n[109] purrr_1.0.4              crayon_1.5.3             rlang_1.1.6             \n[112] KEGGREST_1.48.0",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Statistical testing</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "post-dtu.html",
    "href": "post-dtu.html",
    "title": "4  Post DTU Analysis",
    "section": "",
    "text": "4.1 Detect skipped-exon events\nIn this chapter, we show how to explore the results from the DTU analysis performed using satuRn (see Statistical testing chapter).\nLoad needed objects computed in Statistical testing chapter\nExtract test results\nObtain a GRanges of all the exons present in significant DTU. First, we flatten-out the GRangesList of all the transcripts and include a column to identify if an exon is internal (i.e. is not the first or last in the isoform) or not.\nTo perform exon-level detection events, we include a metadata column that will tell us if a given exon has a - or + coefficient (from satuRn analysis).\nWe are looking to detect exons that were skipped-out due to PTBP1 (down-regulated exons). A transcript with a positive coefficient will be more likely to be expressed when the protein is abundant, and a transcript with a negative coefficient will be less likely to be expressed when the protein is abundant.\nExons that appear in transcripts with negative coefficients and that do not appear in transcripts with positive coefficients may be down-regulated by the protein.\nWe want to get exons that are present in the KD condition (sign -1) that are not present in the WD condition (sign -1)\nlibrary(dplyr)\nflat_sig_exons &lt;- flat_sig_exons |&gt;\n    dplyr::mutate(key = paste0(isoform_id, \"-\", exon_rank))\n\n# 1) split + vs – coef sign\npos_exons  &lt;- flat_sig_exons |&gt; filter(sign ==  1)\nneg_exons &lt;- flat_sig_exons |&gt; filter(sign ==  -1)\n\n# 2) filter non overlaps \ndownreg_candidates &lt;- neg_exons |&gt;\n  filter_by_non_overlaps_directed(pos_exons) |&gt;\n  mutate(SE = TRUE) |&gt;\n  filter(internal == TRUE)\n\n# 3) detect left and right exons from candidates\nleft_keys &lt;- paste0(downreg_candidates$isoform_id, \"-\", \n                    downreg_candidates$exon_rank-1)\nleft_exons &lt;- flat_sig_exons |&gt;\n  filter(key %in% left_keys)\n\nright_keys &lt;- paste0(downreg_candidates$isoform_id, \"-\", \n                     downreg_candidates$exon_rank+1)\nright_exons &lt;- flat_sig_exons |&gt;\n  filter(key %in% right_keys)\n\n# 4) filter in candidates with left and right present in pos_exons\ndownreg_candidates &lt;-  downreg_candidates |&gt;\n  mutate(left_and_right =\n                 left_exons %in% pos_exons &\n                 right_exons %in% pos_exons\n  )\ndownreg_exons  &lt;- downreg_candidates |&gt; filter(left_and_right == TRUE)\n\n# summary\nlength(downreg_exons) # n of spliced exons \n\n[1] 19\n\nlength(unique(downreg_exons$symbol)) # n of dif genes\n\n[1] 16\nList of genes that had skipped-exon events\ndownreg_exons$symbol |&gt; unique()\n\n [1] \"TPM3\"   \"SKP1\"   \"PDLIM7\" \"SMAP1\"  \"TPM2\"   \"RPS24\"  \"DPF2\"   \"EIF4G2\"\n [9] \"ISCU\"   \"FERMT2\" \"PKM\"    \"RNPS1\"  \"EXOC7\"  \"TECR\"   \"AXL\"    \"NSFL1C\"",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Post DTU Analysis</span>"
    ]
  },
  {
    "objectID": "post-dtu.html#analyse-upstream-regions-of-the-down-regulated-exons",
    "href": "post-dtu.html#analyse-upstream-regions-of-the-down-regulated-exons",
    "title": "4  Post DTU Analysis",
    "section": "4.2 Analyse upstream regions of the down-regulated exons",
    "text": "4.2 Analyse upstream regions of the down-regulated exons\nWe know that PTPB1 binds to intronic regions upstream to the skipped exons, regions 15-20 rich in U and C.\nWith the selected down-regulated exon candidates, we can analyze their upstream region and study their bp composition to look for PTPB1 signals.\nGet upstream sequences.\n\nlibrary(Biostrings)\nlibrary(BSgenome.Hsapiens.UCSC.hg38)\n\n#get ranges of 100bp upstream region\nwidth_upstream &lt;- 100\nupstr_downreg_exons &lt;- downreg_exons |&gt;  #GRanges\n        flank_upstream(width = width_upstream) \n\n# get sequence from GRanges \nseq_downreg_exons &lt;-  Hsapiens |&gt;  ## RNAStringSet object\n                       getSeq(upstr_downreg_exons) |&gt;\n                       RNAStringSet() \n\nseq_downreg_exons\n\nRNAStringSet object of length 19:\n     width seq                                              names               \n [1]   100 UCACACUUUCCUAAUUUCUAAUG...UGUGGUUCCUGUGCCUGUCCAG ENST00000328159.8\n [2]   100 CUCUGAAAUGAAGCUUUUAAGUA...AUAUGGUCUUGCAUUGCCUCAG ENST00000522855.5\n [3]   100 GCCUUGUCCCCGGCUGUUCUGAC...GUCUGUCUUAUUUCCUUCACAG ENST00000359895.6\n [4]   100 AUCUCAAAAAUAUACAGGGAUUU...ACUUUUCACCUGUACUCCACAG ENST00000370455.7\n [5]   100 CUUCUCUUCUCUCCUCCACCCGU...CCCCGCCACACACCCCCUGCAG ENST00000329305.6\n ...   ... ...\n[15]   100 UUGACAUGCCGUUUCUAACCUGU...UGCACUGCCUUUCACUCCGUAG ENST00000607838.5\n[16]   100 CUGGGUGCGGGGCCUGGGGGGCA...CUCUGUGUGGCUCUGGUGACAG ENST00000589210.5\n[17]   100 CCUGGUCCAAGCACCUGAGUCUC...CUUACUGUUCCUCUGUCCCCAG ENST00000598987.5\n[18]   100 CCUCACUCCCUUACCCGUGCCAC...UCUCUGUCCUUUCUUCUCACAG ENST00000301178.8\n[19]   100 GCUCCUGGUGCUGUGUCACACCA...AACCUCACGGCUCUGACUUAAG ENST00000476071.5\n\n\nCreate ranges using sliding window of with 10 with 5 bp overlap\n\nwindow_width &lt;- 10\noverlap &lt;- 5\nstep &lt;-  window_width - overlap \nn_windows &lt;- ceiling((width_upstream - window_width) / step) + 1\n\n# create GRanges with the defined window ranges\nwindows &lt;- upstr_downreg_exons |&gt; slide_ranges( width = window_width,  # GRanges\n                                         step = step) # divide into windows\nwindows |&gt; as_tibble()\n\n# A tibble: 361 × 6\n   seqnames     start       end width strand partition\n   &lt;fct&gt;        &lt;int&gt;     &lt;int&gt; &lt;int&gt; &lt;fct&gt;      &lt;int&gt;\n 1 chr1     154169384 154169393    10 -              1\n 2 chr1     154169389 154169398    10 -              1\n 3 chr1     154169394 154169403    10 -              1\n 4 chr1     154169399 154169408    10 -              1\n 5 chr1     154169404 154169413    10 -              1\n 6 chr1     154169409 154169418    10 -              1\n 7 chr1     154169414 154169423    10 -              1\n 8 chr1     154169419 154169428    10 -              1\n 9 chr1     154169424 154169433    10 -              1\n10 chr1     154169429 154169438    10 -              1\n# ℹ 351 more rows\n\n\nGet the sequence for each window\n\nseq_windows &lt;-  Hsapiens |&gt;\n  getSeq(windows) |&gt;\n  RNAStringSet()  # RNAStringSet\n# The RNAStringSet result has n_windows * (# of exons) rows.\nhead(seq_windows)\n\nRNAStringSet object of length 6:\n    width seq                                               names               \n[1]    10 GCCUGUCCAG                                        ENST00000328159.8\n[2]    10 CCUGUGCCUG                                        ENST00000328159.8\n[3]    10 UGGUUCCUGU                                        ENST00000328159.8\n[4]    10 CCCUGUGGUU                                        ENST00000328159.8\n[5]    10 UUCCUCCCUG                                        ENST00000328159.8\n[6]    10 CCUCAUUCCU                                        ENST00000328159.8\n\n\nCalculate the oligonucleotide frequency (A/C/G/U) per window\n\nbp_counts &lt;- oligonucleotideFrequency(seq_windows, \n                                      width = 1) #1-mer\nwindows_bp &lt;- bp_counts / rowSums(bp_counts)\nwindows_bp |&gt; as_tibble()\n\n# A tibble: 361 × 4\n       A     C     G     U\n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1   0.1   0.4   0.3   0.2\n 2   0     0.4   0.3   0.3\n 3   0     0.2   0.3   0.5\n 4   0     0.3   0.3   0.4\n 5   0     0.5   0.1   0.4\n 6   0.1   0.5   0     0.4\n 7   0.1   0.5   0.1   0.3\n 8   0.1   0.5   0.1   0.3\n 9   0.1   0.5   0     0.4\n10   0.3   0.2   0.1   0.4\n# ℹ 351 more rows",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Post DTU Analysis</span>"
    ]
  },
  {
    "objectID": "post-dtu.html#run-splain-app",
    "href": "post-dtu.html#run-splain-app",
    "title": "4  Post DTU Analysis",
    "section": "4.3 Run SPLain app",
    "text": "4.3 Run SPLain app\nSPLain is a Shiny app that allows the exploration and visualization of DTU results. You can find the repository at https://github.com/beamimc/SPLain, and follow the installation instructions. Basically, we need to clone the repo and call the app providing the path of the cloned repo.\n\nsplain_path &lt;- \"your_path/SPLain\" # path to dir with the cloned SPLain repo\napp_dir &lt;- file.path(splain_path, \"app\")\n\n# load the SPLain app \nsource(file.path(app_dir, \"app.R\"))\n\n# Run the Shiny app with your data and app directory\nshiny::runApp(\n  app(\n    se = se,\n    exons = exons,\n    app_dir = app_dir\n  )\n)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Post DTU Analysis</span>"
    ]
  }
]